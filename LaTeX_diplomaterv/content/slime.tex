%----------------------------------------------------------------------------
\chapter{A Slime nyelv}
\label{sec:Slime}
%----------------------------------------------------------------------------
\section{Bemutatkozás}
%----------------------------------------------------------------------------
A szakdolgozat keretében kifejlesztett nyelv a Slime nevet kapta.
A Slime egy UTLE (Universal Templater Language Extension), 
avagy egy más nyelvek fölé szánt univerzális bővítmény, ami template-elést használ.

A fejlesztés során az IRTG kiegészítése az elsődleges cél, de ezt a sok iteráció alatt kinőtte a koncepció. 
Ennek több oka volt. 
Elősször is az IRTG-nek a legtöbb hiányossága későbbi fejlesztés során megszűnhet a nyelv kiegészítésével (Lásd fejezet … ). 
A kiegészítéshez a belső működés módosítására nincs feltétlen szükség. 
Az ALTO-t ugyan viszonylag könnyű kiegészíteni és módosítani, mivel kellően objektum orientált és nyílt forráskódú.
Ugyanakkor állandó fejlesztés alatt áll, ezért a forráskód módosítása és kiegészítése is verzió követést igényel. 
A függőséggel arányosan nő a karbantartási költség. 
Az ALTO fejlődésével pedig sok kód feleslegessé válik. 
Ezért külső megoldás kell. 
Minden nyelv fejlődik, de mindig lesznek fejletlen nyelvek is, amik felett a Slime hasznos lesz.

Programozási és adat leíró nyelveknek széles rétege nem haladják meg azt a szintet, ami a  praktikus használatukhoz szükséges. 
Ennek egyik válfaját alkotják azok a nyelvek, amik még fiatalok, és egyszerűen nem jutottak még el a kellő érettségig. 
A másik válfaj pedig azok a nyelvek, amiknek a fókusza túl keskeny a bennük rejlő lehetőségekhez képest.
A fejlesztőknek sokszor nem éri meg az összes alap funkcionalitást implementálni. 
Jó kérdés, hogy az IRTG a két kategóriából melyikbe esik vagy nem esik. 
A Slime küldetése az, hogy ezeket a nyelveket felemelje egy magasabb szintre azok módosítása nélül. 
Növelje a kódok átláthatóságát, struktúráltságát, és kiírtsa a repetitív kódrészeket.

Az univerzalitást szem előtt tartva egy olyan módszert kell alkalmazni, ami független a kiegészített nyelv fordítójától és szintaxisától. 
Erre a legoptimálisabb megoldás a template-elés. 
Először a kiegészített nyelvre generáljuk a kódot és azt futtatjuk a nyelv saját fordítójával. 
Ez ugyan egy új lépést jelent, de Streameléssel áttetszővé válhat a Slime könnyű súlya miatt. 
Az ötlet persze nem teljesen egyedi. 
Eddig is sokféle template processzort és enginet használtak(Lásd fejezet ...) adatleíró nyelvekhez. 
Ugyanakkor ezek inkább könyvtárak, mintsem nyelvek.
Legtöbbször egy magasabb szintű nyelvből lehet kezelni őket, amiknek a támogatása is szükséges. 
Céljuk a HTML vagy épp CSS kódok aktív manipulációja. 
A Slimeból sem nehéz könyvtárat készíteni, de hosszú távú célja az abszolút önállóság. 
Kerüli a függőséget minden felette lévő rétegtől is.

A réteges architektúra és egyirányú viszony okán a kiegészített nyelvre alárendelt nyelv(subordinate language) ként fogok hivatkozni.
A templatek esetében megszokott terminológia “master dokument” ként hivatkozik az alárendelt nyelv sablonjaira.
Ezzel ellentétben alárendelt dokumentum(subordinate document) ként fogok hivatkozni rá. 

A Slime fiatal, így a Slime-ban is megjelennek még azok a jelenségek, amiket elkerülni igyekszik. 
Nem haladja meg azt a funkcionalitást, amire tervezve lett. 
Közel sem turing teljes. 
Csak a templateléshez és struktúráláshoz szükséges alapfunkciókat tartalmazza(Lásd fejezet ...). 
Nem tartalmazza a legalapvetőbb aritmetikai műveleteket sem. 
A kódjában legtöbbször könnyű, de nem mindig elkerülhető a repetitivitás. 
Még hosszú út áll előtte. 
Ezekre a problémákra és tervezett megoldásaikra a későbbiekben fogok kitérni. 
A Slime így is jelentős fejlődést jelent olyan nyelvek számára, amiken a tünetek sokkal súlyosabban jelentkeznek. 
Ilyen nyelv az IRTG, HTML, XML és irónikusan annak az ANTLR-nek a lexer és parser nyelvtan leíró nyelve, amit a Slime jelenlegi fordítója használ(lást Példák …). 
Tehát végső soron a Slime egy olyan nyelv, ami saját magának az implementálását is határozottan könnyebbé tette volna.


%----------------------------------------------------------------------------
\section{Tervezési szempontjai}
%----------------------------------------------------------------------------
A Slime a következőkre összpontosít:
\begin{itemize}
\item alárendelt és fölérendelt nyelvtől való függetlenség
\item könnyű súly és sebesség
\item platform függetlenség
\item könnyű bővíthetőség
\item esztétikum és egyéniség
\item kód átláthatósága és könnyen érthetősége
\item szabad tördelhetőség akár több fájlba
\item meredek tanulási görbe
\item hatékonyan programozás az alárendelt nyelven
\end{itemize}

Eddig a nyelvektől való függetlenség volt a legalaposabban tárgyalva. 
A nyelv külön fordítót, templatelést és szöktetést használ e célból.

A könnyű súlyt könnyen parszolható szintaxissal és egyszerű műveletekkel támogatja. 
Később a robosztus külső könyvtárak elhagyása is sokat fog segíteni.

A platform függetlenség okán Kotlinban készült az első fordító, ami JVM-en fut. 
Igaz egy C++ 20 verzió is tervben van a könnyű súly miatt. 
A jelenlegi verzió még a karbantarthatóság miatt OOP alapokon nyugszik, de a C++ 20 már DOP(data oriented programming) alapú lesz.

A könnyen bővíthetőséget modularitással és egységes szintaxissal támogatjuk.

Az esztétikum és felismerhetőség is első sorban a szintaxisra vonatkozik. 
Itt a legfontosabb az átláthatóság. 
Fontos, hogy szép kódunk legyen, amiben a nyelvi elemek jól felismerhetőek.
Ugyanakkor az is fontos, hogy a Slime kódja kitűnjön az alárendelt nyelv kódjából. (lásd fejezet ...)

A szabad tördelhetőségben segítenek sokat a zárójelek, változók és az importálás megvalósítása. (lásd fejezet ...) 
A könnyen tanulhatóságot a beszédes, de tömör jelölések, kevés, de sok oldalú műveletek és következetes működés és a kódok átláthatósága is segíti.

A hatékony programozást a tömörített kifejezések és a szükségtelen jelölések elhagyása segítik.

Sokszor kellett kompromisszumokat kötni a szempontok között. 
Ezeket a döntéseket ugyanakkor legtöbbször inkább elkerültük. 
Fontos, hogy rugalmasak lenni, és engedni a programozót a saját stílusát követni. 
A nyelv hemzseg a zárójelektől a könnyű parszolás és átláthatóság érdekében.
Ugyanakkor vannak biztosítva módszerek a csukó zárójelek esetenkénti elhagyására.
Sok nyelv az adatot elkülöníti a kódtól. 
Slimeban a kód tartalmazza a templatet, de külön fájlba szervezéssel elkülöníthető. 
Nem a Slime-ba ágyazzuk az alárendelt nyelv kódját. 
Az alárendelt nyelv kódjába ágyazzuk a Slime-ot. 
Így a Slime használatának mennyisége teljesen opcionális. 
A felhasználó hagyatkozhat teljesen a Slime-ra, vagy használhatja csak a legrepetitivebb kód részek esetén. 
A Slime esetén akár saját maga is könnyen lehet az alárendelt nyelv. 
Ezt a szöktető zárójelek nagyban segítik. 
A REGEX-ek esetén például csak egy karaktert lehet szöktetni, így REGEX-ek között keresni nagyon nehézkes. 
Slime esetében az alárendelt Slime kód részeket egyszerűen \{” ”\} szöktető zárójelek közé rakjuk.


%----------------------------------------------------------------------------
\section{Alternatívák template-elésre }
%----------------------------------------------------------------------------


%----------------------------------------------------------------------------
\section{Az Slime alapjai}
%----------------------------------------------------------------------------
Nincs nyelv, amiben könyebb "Hello World"-öt írni, mint Slime-ban!
Csak leírod, és a kimenetben benne lesz.
A Slime egy letisztult nyelv. 
Összesen tizenegy példányosítható típust és tíz műveletet tartalmaz. 
Egységes és csak erősen indokolt esetekben tér el a természetes, bevett megoldásoktól.
A továbbiakban a szintaxist, típusokat és műveleteket bonyolultság szerinti sorrendben igyekszem leírni.
Először a szintaxis alapjait írom le.
Utána az absztrakt őstípusokkal folytatom.
Ezt követően bemutatom a sablon deklaráláshoz szükséges típusokat.
Ezt követően mutatom be az alap műveleteket.
Majd folytatom a tároló típusokkal.
A hatodiktól a nyolcadik alfejezetig arról írok, hogy a Cont osztályokon hogyan végezhetőek műveletek.
Ezt követi a név manipuláció
Végezetül bemutatom a haladó szintaxist.

  

%----------------------------------------------------------------------------
\subsection{Alap Szintaxis}
%----------------------------------------------------------------------------
A szintaxis terén volt a legnehezebb megtalálni a hangsúlyt a tömörség az átláthatóság és a tanulhatóság között. 
Fontos volt az, hogy a jelölések már bevettek legyenek vagy következetesek, hogy könnyű legyen tanulni. 
De az átláthatósághoz az is fontos volt, hogy a jelölések egyediek legyenek

A bevett jelölésekhez a c alapú nyelvek szintaxisa szolgált alapul. 
Mint a C alapú nyelvek, a Slime is a kapcsos zárójelekkel jelöli alapvetően a blokkokat. 
A műveleteket az alárendelt nyelv kódjába ágyazzuk közvetlenül.
Ezért jelöl minden műveletet zárójel, hogy jól elkülönüljenek. 
Ez rendes tördelés mellett az átláthatóságot is segíti, és használatával a műveleti sorrend is egyértelmű. 
A C alapú nyelvekkel ellentétben viszont a blokkok típusát a blokkon belül jelöli. 
Szintén az alárendelt kód és a Slime kód elkülönítését célozza ezzel.
Fontos, hogy a műveletek típusa és attribútumai is jól elkülönüljenek.
Ezért a művelet típusát 1-2 karakterrel jelöljük.
Ez a zárójelek hierarchiájának átlátásában és a tördelésben is sokat segít. 
A zárójeleken belül az attribútumokat vesszővel és kettősponttal választjuk el. 
A kettőspont választja el a függőségben lévő attribútumokat és a vessző a függetleneket. 
Ha az attribútumok között összetettebb hierarchia van, azt a kettőspont mellett kerek zárójelek is jelölik. 
Egyes műveletek esetén a főbb attribútum halmazokat saját operátorral is elválasztjuk. 
Például deklaráció során a létrehozott változó metaadatait(nevek és típus) az attribútumaitól egy “:=” operátor választja el.

  

%----------------------------------------------------------------------------
\subsection{Vari és Cont őstípus}
%----------------------------------------------------------------------------
A Slime egy erősen típusos nyelv.
Nincsen benne öröklődés, de van két absztrakt ős típus.
A Slime összes típusának közös absztrakt őstípusa a Vari(variable).

Minden Vari példánynak lehet akár több, akár nulla neve.
Ezek a nevek az angol ábc kis-nagy betűit, alulvonást és számokat tartalmazhatnak. 
Számokkal ugyanakkor nem kezdődhetnek.
Egy névtelen változó csak az őt birtokló változókon keresztül érhető el.
A több név több esetben is hasznos lehet.
Például az éppen többet használt változókat hivatkozhatjuk a rövidebb nevükön.
Ritkább használat esetén pedig hivatkozhatjuk őket a hosszabb nevükön.
Tömören programozunk, és mindig mindent elérünk egyszerre.
A programozási környezetek gyakran tartalmazzák az automatikus rendezés funkciót.
Egy Slime környezet lehetővé tehetné, hogy a változó meghivatkozásainál a nevét a leghosszabbra cseréli.
Így a programozó gyorsan kódol és maximum három gomb nyomásra érthetővé teheti a gyorsan leírt kódot.
Vagy például többen dolgoznak egy projekten, de mindenki más terminológia szerint dolgozik.
Ilyenkor mindenki hozzáadhatja a változókhoz azt a nevet, ami neki otthonos.
A nevek teljes mértékben elvannak egymás mellett.
Egy változóhoz nevek később is adhatóak a Name típus segítségével [lásd ... fejezet].
Az új nevek annak a Slime fájlnak a namespace-éhez fognak tartozni, amelyikben hozzá lettek adva az adott változóhoz.
Így lehet például egy importált fájl változóit könnyebben elérhetővé tenni.
Ha egy név már foglalt az adott fájlban, akkor egyszerűen felülíródik.
Ekkor a környezet persze dobna warningot.
A több név gyakorlatilag a referenciákat helyettesíti.
Ugyanakkor ez egy sokkal magasabb szintű megoldás.
A változó is tudja, hogy honnan érhető el és milyen név szerint.
Későbbiekben már a Name típus nélkül is megoldható lesz a nevek kezelés.

Minden Vari-nak létezik a következő négy attribútuma:
\begin{itemize}
\item \emph{names:} 
A változó nevei a fájl elérése szerint.
\item \emph{self:} 
A változó maga. 
Ez a "referencia" helyett magára a változóra hivatkozik.
Ha egy változó közvetlen elérhető, akkor a meghivatkozása nem tartalmaz pontot.
Bizonyos esetekben a parszer ezért a meghivatkozást Name típusú változónak tévesztheti.
Ilyenkor a self attribútummal egyértelműsíthetjük, hogy a változó elérésre gondoltunk, és nem Name típusú változra.
\item \emph{copy:}
Ez az attribútum a változóból egy új másolatot ad vissza név nélkül
Későbbiekben a copy-ból három féle fog létezni. 
A copyS sekély, a copyD mély és a copy\{\$integer\$\} adott mélységű másolatot fog visszaadni.
\item \emph{type:}
Ez az attribútum jegyzi a változók típusát.
Egy Type típusú változó, ami a változó itt felsorolt négyen túli attribútumait jegyzi.
Van egy címkéje, amivel lekérhető.
\end{itemize}

Ezen kívül egyes típusoknak vannak további attribútumai, de metódusai nincsenek. 
Csak a mindenkin végrehajtható operációkat kezelik le másképp. 
Ez a négy operáció a:
\begin{itemize}
\item \emph{deklaráció:} 
Egy új változó létrehozása az adott típussal.
Nem csak ezzel a művelettel lehet változót létrehozni, de ez a leg sokoldalúbb módszer rá.
Minden típus példányosítható vele.
A változó nevei is megadhatóak egyből.
Képes más műveletek kimenetéből példányosítani.
\item \emph{törlés:} 
Törli egy változónak az egyik nevét vagy elveszi egy birtokosától.
Egy változó csak akkor szabadul fel, ha az összes nevéről törlik és senki sem birtokolja.
Ha egy változó self attribútumára hívnak törlést, akkor az összes neve szerint törli magát az összes Slime fájlból.
Ugyanakkor a birtokosai továbbra is elérik.
Akkor lehet igazán hasznos, ha nagyon nagy szöveghalmazzal foglalkozunk, vagy le akarunk tiltani ideiglenesen létrehozott neveket.
\item \emph{hozzá adás:}
A hozzáadás egy sok oldalú művelet. 
Ez végez ugyanis minden konkatenációt, beszúrást és deklaráció utáni értékadást.
\item \emph{kiterjesztés:}
A kiterjesztés a C nyelvek ToString műveletének felel meg. 
Szöveggé alakítja a változókat.
Ugyanakkor az alárendelt nyelv kódjába ágyazva kiírást is végez.
Ebből az extra funkcionalitásból származik a neve is.
\end{itemize}

Ezek a műveletek nyílván valóan alap követelményei a sablon kezelésnek. 
Ha nem tudunk sablonokat létrehozni, beszúrni egymásba és kiírni, akkor nem látjuk el a nyelv alap funkcióit.
A törlés persze másodlagos, de igazán nagy adathalmazok esetén elengedhetetlen.
Az ideiglenesen a változókhoz adott nevek törlésének is kényelmes módja.
Nagy adatok esetén ugyan olyan fontos a változók hatékony tárolása és kezelése is.
Ebben segítenek a tároló osztályok.
Az operátorok szintaxisát és pontosműködését később részletezem. 

A tároló típusok közös absztrakt őse a Cont(container) osztály.
Működésük nagyban eltér, de vannak közös attribútumaik:
\begin{itemize}
\item \emph{content:} 
Minden Cont változó tárolhat más Vari változókat.
Ezek listába(List) szervezve a változó content attribútuma.
\item \emph{iter:} 
Minden Cont változónak van egy iterátora.
Ezzel érhető el ciklus szerű viselkedés a Slime-ban.
Későbbi fejezetben fogom bemutatni.
\item \emph{\{\$integer\$\}:} 
Minden Cont változó indexelhető is.
Túlindexelés esetén hibát dob.
Későbbiekben lehetséges lesz hátulról indexelni is és tartományt indexelni.
Utóbbi esetben egy új Cont változó fog létrejönni.
\end{itemize}

Ezeket is majd egy későbbi fejezetben mutatom be.

%----------------------------------------------------------------------------
\subsection{Sablon típusa és alkotóelemei}
%----------------------------------------------------------------------------
Egy sablon kezelésre szakosodott nyelvben a legfontosabb, hogy hatékonyan lehessen létrehozni és kezelni sablonokat.

A Slime-ban a sablonokat a Temp(template) típus segítségével kezeljük. Ez felelős minden sablon művelet megvalósításáért.

A legtöbb nyelvben a sablonoknak két féle komponense van, a szöveg és a mező. 
A Slime-ban ez nem elegendő.
Ugyanis a Slime nem különíti el a kódot és az adatot külön fájlba.
Nem akarjuk azt, hogy az adat tördelése befolyással legyen a kód tördelésére, de nem is akarjuk a sablonokat soronként kezelni.
Erre a Slime megoldása a speciális karakterek, mint harmadik komponens.

A három komponens fajta kezelésére három típusunk is létezik:
\begin{itemize}
\item \emph{Text:} 
Kezel minden szöveget, így az alárendelt kódrészleteket is.
\item \emph{Slot:} 
Kezeli a sablon mezőit.
Egy template-hez ezek később is hozzáadhatóak.
Egy mezőnek több címkéje is lehet.
A mezők címkéi egyezhetnek is.
Ha a Temp egy mezőjébe szúrnak valamit, akkor az megszűnik.
\item \emph{Spec:} 
Ezzel adhatóak meg speciális karakterek 3-3 kódnévvel.
Jelenleg a Slime 10 féle speciális karaktert kezel:
\begin{itemize}
\item \emph{$‘\backslash n’$:} e, ent, enter, 
\item \emph{$‘\backslash r’$:} r, ren, renter, 
\item \emph{$‘\backslash t’$:} t, tab, tabulator, 
\item \emph{‘ ’:} s, spa, space 
\item \emph{‘.’:} pe, per, period 
\item \emph{‘?’:} qm, qum, question\_ mark 
\item \emph{‘!’:} em, exm, exclamation\_ mark 
\item \emph{‘,’:} co, com, comma
\item \emph{‘:’:} cl, col, colon 
\item \emph{‘;’:} sc, sec, semicolon
\end{itemize}
Ez még később ki lesz egészítva a teljes unicode tartományra. Ekkor minden karakter megadható lesz a uni code-ja szerint is.
Később még ki lesz egészítve a karakterek legnépszerűbb nyelvekben használt neveivel is.
\end{itemize}

Ezek olyan alapvető típusok, hogy a hatékonyabb deklarációjukat úgynevezett típus zárójelek is segítik. 
Ezek a zárójelek név nélküli példányokat hoznak létre.
A zárójelekre a típusok nevének csupa nagy betűs változatával hivatkozok:

TEXT: \{"text"\} pl.: \{" This is a text "\}

SLOT: \{\$ tags \$\} pl.: \{\$ tag \$\}

SPEC: \{@ code @\} pl.: \{@ enter @\}

Ezeken belül az érték adást egyedi szintaxis is segíti.
Text esetében minden whitespace karkater bent marad a szövegben.
Éppen ezért a Text zárójelet használjuk szöktetésre is.
Erre mindenképpen szükség van, ha az alárendelt nyelv és a Slime szintaxisában túl sok a közös.
A Slot és Spec zárójelekben minden WhitSpace karakter szöktetve van.
A Slot címkéjére és a Spec kódjaira is érvényes a Slimban a nevekre érvényes formai megkötés.

A Temp típusnak is van típus zárójele. 
Ezen belül a szöveg elemeket nem kell TEXT-be zárni, de lehet, ha szöktetni akarunk. 
A sor végi, eleji és elválasztó karakterek szöktetésre kerülnek. Például:\begin{verbatim}
{| 
		{@e@}{@t@} text {$ slot $} 
		{@e@}{@t@}{"text {$"}
|}
vagy:
{|{@e@}{@t@} text {$ slot $}{@e@}{@t@}{"text {$"}|}
\end{verbatim}Ez egy ilyen sablont eredményez:

		text \{\$ slot \$\}
		
		text \{\$ 
		
Ez ugyan összetettebb, mint más nyelvekben, de a speciális karakterek használata teljesen opcionális.
A TEMP-ek tömörségéről pedig a haladó szintaxis gondolkodik, amit egy későbbi fejezetben írok le. [...]


%----------------------------------------------------------------------------
\subsection{Operátorok és egyszerű eseteik}
%----------------------------------------------------------------------------
Az operátorokkal lehet elvégezni a Slime minden alapműveletét el lehet végezni
Ezek a deklaráció, törlés, hozzáadás és kiterjesztés. 

\begin{itemize}
\item \emph{deklaráció:} 
Jele az "=".
Decl ként hivatkozunk rá.
DECL ként hivatkozunk a zárójelre
Egy új változó létrehozása az adott típussal.
Minden típus példányosítható vele.
DECL-ben a változó neveinek vesszővel való felsorolását egy : és a változó típusa követi. 
A metaadatokat a := választja el a változó értékétől.
Későbbi verziókban a típus paraméter elhagyható lesz, ha egyértelmű a változó értékéből. 
A változó értéke megadható mindig egy azonos típusú változóval
Ez lehet név szerinti meghivatkozás:
\begin{itemize}
\item\emph{Text:} \{= tx2 : Text := text1 =\}
\item\emph{Slot:} \{= sl2 : Slot := slot1 =\}
\item\emph{Spec:} \{= sp2 : Spec := spec1 =\}
\item\emph{Temp:} \{= tm2 : Temp := temp1 =\}
\end{itemize}
Ez is egy módja annak, hogy egy változóhoz új neveket adjunk.
Így másolatot is készíthetünk:
\begin{itemize}
\item\emph{Text:} \{= text1\_ copy : Text := text1.copy =\}
\item\emph{Slot:} \{= slot1\_ copy : Slot := slot1.copy =\}
\item\emph{Spec:} \{= spec1\_ copy : Spec := spec1.copy =\}
\item\emph{Temp:} \{= temp1\_ copy : Temp := temp1.copy =\}
\end{itemize}
Érték ként megadható típus zárójel is:
\begin{itemize}
\item\emph{Text:} \{= text1 : Text := \{"This is a text"\} =\}
\item\emph{Slot:} \{= slot1 : Slot := \{\$ slot1 \$\} =\}
\item\emph{Spec:} \{= spec1 : Spec := \{@ enter @\} =\}
\item\emph{Temp:} \{= temp1 : Temp := \{|This is a template:\{\$slot\$\}|\} =\}
\end{itemize}
Képes más operációk kimenetéből is példányosítani:
\begin{itemize}
\item\emph{deklaráció:} \{= text1 : Text := \{= : Text := \{"This is a text"\} =\} =\}
\item\emph{hozzáadás:} \{= temp : Temp := \{+ … +\} =\}
\item\emph{kiterjesztés:} \{= text1 : Text := \{* … *\} =\}
\end{itemize}
Persze a törlésből nem lehet, mivel annak nincs visszatérési értéke.
\item \emph{törlés:} 
Jele a "X" vagy a "x".
Dele ként hivatkozunk rá.
DELE ként hivatkozunk a zárójelre.
A változó elérését kell benne megadni.
Törli egy változónak az egyik nevét vagy elveszi egy birtokosától.
Egy változó csak akkor szabadul fel, ha az összes nevéről törlik és senki sem birtokolja.
Ha egy változó self attribútumára hívnak törlést, akkor az összes neve szerint törli magát az összes Slime fájlból.
Akkor lehet igazán hasznos, ha nagyon nagy szöveghalmazzal foglalkozunk, vagy le akarunk tiltani ideiglenesen létrehozott neveket.
A törlés többek között történhet név szerint: \{X name1 x\} vagy a birtokoson keresztüli elérési út szerint: \{X birtokos.attribute1 x\} 
\item \emph{hozzáadás:}
Jele a "+".
Plus ként hivatkozunk rá.
PLUS ként hivatkozunk a zárójelre
A hozzáadás egy sok oldalú művelet. 
Ez végez ugyanis minden konkatenációt, beszúrást és deklaráció utáni értékadást.
Lehet vele Slot-ba beszúrni Temp-et, Text, Spec vagy Slot változót: 
\begin{itemize}
\item\emph{Text:} \{+ temp1.slot1 :+ \{"This is a text"\} +\}
\item\emph{Slot:} \{+ temp1.slot1 :+ \{\$ slot1 \$\} +\}
\item\emph{Spec:} \{+ temp1.slot1 :+ \{@ enter @\} +\}
\item\emph{Temp:} \{+ temp1.slot1 :+ \{|This is a template:\{\$slot\$\}|\} +\}
\end{itemize}
Utóbbi három ilyenkor template-té konvertálódik. 
Ilyenkor a bal oldali Temp változót adja vissza.
Lehet vele egy Temp-et bővíteni Text-tel, Spec-cel, Slot-tal, Temp-pel:
\begin{itemize}
\item\emph{Text:} \{+ temp1 :+ \{"This is a text"\} +\}
\item\emph{Slot:} \{+ temp1 :+ \{\$ slot1 \$\} +\}
\item\emph{Spec:} \{+ temp1 :+ \{@ enter @\} +\}
\item\emph{Temp:} \{+ temp1 :+ \{|This is a template:\{\$slot\$\}|\} +\}
\end{itemize} 
Utóbbi esetben Temp összetevőit egyesével fűzi a Temp végére.
Ilyenkor is a bal oldali Temp változót adja vissza.
Hozzáadás esetén bal oldalt csak változó elérési útja állhat.
A beszúrni kívánt oldalt viszont típus záróhjel helyett megadhatjuk elérési úttal is.
Lehet bármyel művelet kimenete is jobb oldalt.
\item \emph{kiterjesztés:}
jele a '*'.
Exte ként hivatkozunk rá.
EXTE ként hivatkozunk a zárójelre
A kiterjesztés a C nyelvek ToString műveletének felel meg. 
Szöveggé alakítja a változókat.
Ugyanakkor az alárendelt nyelv kódjába ágyazva kiírást is végez.
Ebből az extra funkcionalitásból származik a neve is.
\begin{itemize}
\item\emph{Text:} Egy másolatot térít vissza.
\item\emph{Slot:} A Slime formátumában adja vissza.
\item\emph{Spec:} A kulcsnak megfelelő karakterré alakítja.
\item\emph{Temp:} Minden elemét sorban kiterjeszti és a szövegeket összekonkatenálja
\end{itemize}
Ezek az értékek is megadhatóak elérési úttal vagy típus zárójellel vagy egy művelet ként, aminek van visszatéréis értéke.
\end{itemize}

Természetesen minden operátor zárójel szökteti a whitespace karaktereket.

Szintaxis összefoglaló táblázat:
\begin{center}
  \begin{tabular}{ | l | l | c | c | l |}
    \hline
    művelet		& jel	 	& kódnév 		& zárójel neve	& belső szintax		\\ \hline
    deklaráció	& = 		& Decl		 	& DECL			& meta adat := érték	\\ \hline
    törlés		& X vagy x	& Dele		 	& DELE			& változó neve		\\ \hline
    hozzáadás	& + 		& Plus		 	& PLUS			& elérés:+érték		\\ \hline
    kiterjesztés& * 		& Exte		 	& EXTE			& érték				\\
    \hline
  \end{tabular}
\end{center}


%----------------------------------------------------------------------------
\subsection{Cont típusok}
%----------------------------------------------------------------------------

Alapvető Cont típusok:
\begin{itemize}
\item \emph{Temp:} 
A Temp is Const típus. 
Iterátorai vannak, content attribútuma és indexelhető.
Ezen kívül a text, slot és spec változói típusonként is lekérhetőek.
Ekkor a második legalapvetőbb Cont típusba, a List-be rendezve adja vissza őket.
\item \emph{List:} 
A List az első a C-ből megszokott tároló osztályokból, ami implementálásra került.
Később még természetesen bővülni fog a kínálat.
Mint a legtöbb C nyelvben, itt is típusos.
A nyelvben az egymásba ágyazott típusokat kettősponttal tagoljuk, így: List:List:Temp
Ez C nyelvekben így néz ki: List<List<Temp> >
A zárójelezés viszont csak akkor praktikus, ha egy típusba egyszerre több típus is ágyazható. 
A Slime jelölése viszont kiegészíthető zárójelezéssel. 
Például, ha bevezetjük majd a dictionary-ket Dict néven:

List:Dict:(Text, List:Temp)

Itt azért nem a kacsacsőr zárójeleket használjuk, mert azokkal már a kompakt zárójelezést jelöljük.
A kopakt zárójelek jelölésére sokkal alkalmasabb a kerek zárójelnél. 
Könnyebb észrevenni az alárendelt kódrészletekben.

Egy List beágyazott típusa Vari is lehet vagy Cont és akkor bármely Cont vagy Vari tárolására képes.

A List használata előnyös gyakran változó hosszú adathalmazok tárolására és mozgatására.
\item \emph{Type:} 
A Type nem más Vari példányok tárolására lett kitalálva.
Új típusok bevezetésére való.
Azoknak metaadatát tárolja
Ezek a típusok a C struktúráihoz hasonlóan viselkednek.
Függvényeket ugyan nem tartalmazhatnak, de névvel és típussal rendelkező attribútumaik vannak.
Két nem módosítható és azonos hosszú List-et tartalmaz.
Egyik lista tartalmazza az atribútumok neveit (attrs néven).
Itt az attribútumoknak csak egy neve lehet.
A másik lista pedig típusok listáiból áll (types néven).
Azért listáiból, mert így beágyazott típusokkal rendelkező típusokat is képes tartalmazni.
Ezekbe csak az alap négyen túli attribútumai szerepelnek az új típusnak.
Az iterátora párhuzamosan megy végig a két listán név-típuslista párokat adva vissza List:Vari változókban.
Ezen kívül Type-nak még egy címkéje van tag-ként, ami a típusnevét adja vissza.
Azért nem név ként tárolja, mert így nem függ a fájloktól.
\item \emph{Inst:} 
A Type-pal a programozó által létrehozott típusok összességét jellemzem.
Az Inst még absztrakt típus ként sem létezik.
Nem példányosítható, és nem létezik List:Inst.
Minden példánynak a Type-pal deklarált típus a típusa.
Egy fix méretű List:Vari-t tartalmaz, aminek nincs minden értéke megadva.
Az iterátora a nem megadott értékeket egyszerűen átugorja.
Minden attribútuma lekérdezhető.
\item \emph{File:} 
Slimeban az importálás File típusú változókkal van megvalósítva.
Inicializálásuk után ezek tartalmazzák az importált Slime fájl kimenetét és elérhető változóit.
A kimenetük egy Text típusú outp változóban érhető el.
Az aktuális fájlban létrehzott változók is egy ilyenben vannak tárolva.
Ez a változó self néven el is érhető.
A names, self, copy, type, cont, iter, \{\$szám\$\} és outp változók felülírhatatlanul az aktuális(fókuszban lévő) File attribútumait jelentik.
Éppen ezért bár ilyen nevű változókat lehet létrehozni, elérhetetlenek lesznek ezen a néven.
Viszont az aktuális File összes atribútuma a létrehozott változók kivételével nem törölhető.
Ezért az azok neveit törölve legalább az azokkal a nevekkel létrehozott változók törölhetőek.
\end{itemize}


%----------------------------------------------------------------------------
\subsection{Cont típusok Decl művelete}
%----------------------------------------------------------------------------
Mivel a nyitó és csukó zárójelek rakása macerás, ezért elég korán be lettek vezetve a több műveletes zárójelek.
Ez annyit tesz, hogy minden típus és operátor zárójelben többször is el lehet végezni a típusának megfelelő műveletet.
Ekkor a műveletek attribútumait pontosvesszővel választjuk el.
Ez a jelölés is természetesen a C alapú nyelvekből származik. 
Ekkor a visszatérési értékkel rendelkező zárójelek List típusú visszatérési értéket adnak.
Ha a műveletek visszatérési értéke más típusú, akkor ez egy List:Vari. 
Sok nyelvben megoldották már a pontosvesszők elhagyását.
Ilyenkor mindig a sortörés karaktereket használták fel.
A Slime  esetében ez több helyen is problémás lett volna.
Például a sablonoknál sem akarjuk a több soros sablonokat mindig egy sorban megadni
(Későbbiekben persze egyes műveleteknél el lehet majd hagyni a pontosvesszőt sortörés esetén)

Cont változókat éppen ezért lehet a beágyazott típusnak megfelelő típus zárójellel is deklarálni:

\{= specL1 : List:Spec := \{@ e;t @\} =\}

Ugyanakkor mindig megadhatóak egyszerűen az elemeik felsorolásával is:

\{= specL1 : List:Spec := \{@ e @\}, \{@ t @\} =\}

vagy pl.:

\{= temp1 : Temp := \{@ e @\}, \{@ t @\} =\}

Minden Vari deklarálható az elérési útjával is.
Ez nevek és indexek ponttal tagolt sorozatával adhatjuk meg.
Ezt az elérést path ként hivatkozom.
[Későbbiekben ez is lekérdezhető lesz minden változóból.]
Például az inst1 nevű Inst attr3 nevű List típusú attribútumának a harmadik eleméhez vezető path: inst1.attr3.2 
(mivel a lista első elemének 0 az indexe)

A Type alapvetően név típus párokkal adható meg:

\{= tempi : Type := te1 : Text, te2 : Text, sp1 : Spec, sp2 : Spec, sl1 : Slot, sl2 : Slot=\}

Ugyanakkor elég a típusok azonos típust attribútumonként egyszer jelölni:

\{= tempi : Type := te1, te2 : Text, sp1, sp2 : Spec, sl1, sl2 : Slot =\}

Megadható ugyan a nevek és típus listák két listájával is:

\{= tempi : Type := \{+ :List:Name := te1, te2, ... +\}, \{+ :List:List:Type := \{+ List:Type := Text +\}, \{+ List:Type := Text +\}, .... +\} =\}

és a név típus párok mint listák listájaként:

\{= tempi : Type := \{+ :List:Vari := te1, \{+ List:Type := Text +\} +\}, \{+ :List:List:Type := te2, \{+ List:Type := Text +\} +\} .... =\}

De ezeket magától értetődő okokból nem használjuk.
Használatuk csak az egységesség okán lehetséges.
Ha a típusok egyértelmű esetekben elhagyhatóak lesznek, akkor használhatóbbak lesznek ezek a formátumok is.

Az Inst-eknél definiálhatjuk, hogy melyik attribútumoknak adunk értéket:

\{= t1 : tempi := te1 := \{”text”\}, sl3:=\{\$slotty\$\}, sp2:=\{@e@\} =\}

de erre sem vagyunk kötelesek, ha az értékeket sorrendben adjuk meg:

\{= t1 : tempi := \{”text”\}, \{”text”\}, \{”text”\}, \{@e@\}, \{@e@\}, \{@e@\}, \{\$slotty\$\}, \{\$slotty\$\} =\}

Nem vagyunk kötelesek minden attribútumnak értéket adni.
Ha egyes attribútum típusokból az utolsóknak nem kívánunk értéket adni, akkor az a későbbi verziókban kihagyható lesz.

A File egy text-tel hozható létre, ami a futtató gépen az elérési útvonalát tartalmazza:

\{= f1 :File := {"/home/boss/Documents/test\_complex\_long"\} =\}

Ekkor a file le is fut és a generált kimenetet is fogja tartalmazni az outp változója.
A létrehozott változóiból viszont csak a nem törölt változói lesznek elérhetőek.

Name teljes mértékben Text módjára viselkedik. 
Deklarációja is Text értéket vár. 
Ugyanakkor ha egy változóba beleszúrunk egy nevekből álló listát, akkor az a neveihez adódik hozzá. 
(Későbbiekben ez meg fog szűnni. 
A változók name attribútumába kell majd Text listát szúrni)



%----------------------------------------------------------------------------
\subsection{Cont típusok Plus művelete}
%----------------------------------------------------------------------------
Lehet vele listába elemet szúrni:

Plus: \{+ list1 :+ vari1 +\}

Akár adott indexen is:

\{+ list1.1 :+ vari1 +\} 
\{\# A második eleme lesz a listának. 
A második elem nem cserélődik le, csak eltolódik \#\}

Lehet vele Inst attribútumának értéket adni:

\{+ inst1.attr1 :+ vari1 +\} 

Egy Temp Slot-jába Temp tartalmú Listát szúrva annak minden elemére elvégzi a beszúrást:

\{+ temp1.slot1 :+ \{= :List:Temp :+ temp2, temp3, temp4 =\} +\} 

Az eredményül kapott Temp-eket egy listában téríti vissza.
 
Egy Const változót egy másikba szúrva, specifikálható, hogy az egyik elemeit a másik melyik elemeibe szúrja bele:

\{+ temp1 :+ \{= :List:Temp :+ temp2, temp3, temp4 =\} : slot1 :+ 2 , slot2 :+ 1, slot3 :+ 0   +\} 

Ekkor szókásos mód a bal oldali változót téríti vissza. 

Const változóhoz egy másikat adva az előbbihez hozzáfűzi az utóbbi elemeit:

\{+ list1 :+ list2 +\} \{\# adds all elements of list2 to list1 \#\}

Const változóhoz egy másik iterátorát adva az előbbihez hozzáadja az utóbbi elemeit:

\{+ list1 :+ list2.iter +\} \{\# plus all elements of list2 to list1 \#\}

Egy Const változó iterátorához egy másikét adva az előbbi minden eleméhez hozzáadnja az utóbbi azonos indexű elemét:

\{+ list1.iter :+ list2.iter +\} \{\# plus all elements of list2 to the elements of list1 on the same index \#\}

Egy Const változó iterátorához egy másik Constot adva az előbbi minden eleméhez hozzáadja az utóbbit:

\{+ list1.iter :+ list2 +\} \{\# plus list2 to all elements in list1 \#\}

Lehetséges Const változóhoz adott indexen is hozzáadni a másik elemeit:

\{+ list1.1 :+ list2 +\} \{\# adds all elements of list2 to list1 \#\}

Egy Temp-be beszúrhatunk egy Inst-et így is:

\{+ temp1 :+ inst1 : sl1 :+ at1 , sl2 :+ at2+\}

de, ha az Inst megfelelő attribútumainak ugyanaz a neve, mint a Temp megfelelú Slot-jainak:

\{+ temp1 :+ inst1 +\}

akkor sorrendtől függetlenül jól fog elvégződni a hozzáadás.

Ez teszi a Cont leszármazottakat igazán hasznossá.
Ha az adatainkat megfelelő attribútum nevekkel rendelkező Inst-ek List-jében tárolom,
akkor abból egy sorban legenerálható az összes kimeneti adat:

\{= list2 : List:Temp := \{+ temp1 :+ list1.iter +\} =\}

Ez a list1 elemeit egyesével fogja hozzáadni a temp1-hez.
Mivel a temp1 elemei Inst-ek a megfelelő adatokkal, minden beszúrás a megfelelő mezőkön fog történni.
A kimenetet képző kód pedig lista ként el lesz tárolva list2-ben.



%----------------------------------------------------------------------------
\subsection{Cont típusok és az Exte művelet}
%----------------------------------------------------------------------------
Exte zárójelben a kiírni kívánt elemeket pontosvesszűvel elválaszva soroljuk.
Ha közvetlen az alárendelt kódba van ágyazva, akkor az Exte a kimeneteit egymás után fogja kiírni elválasztás nélkül:

\{* variable1; variable2*} \{\# returns it as list of text\#\}

A Const változók kiiratásánál adható meg elválasztó szöveg.
Ez lehet speciális karakterek sorozata vagy Temp:

\{* list1 : \{@ e;e;e@ \} *\} \{\# You can add divider character by special character \#  \}

\{* list1 : \{|This is a temp, witch can include special character too. Like \{@ e@ \} for example|\} *\} \{\# or template\# \}

Azért nem lehet szöveg, mert az Temp ként is könnyen megadható, de a Temp-pel ellentétben nem tartalmazhat speciális karaktereket.
Lésőbb a Text-ees verzió is bevezetésre fog kerülni.

Ha egy Const változó tartalmaz egy másikat, akkor az utóbbi elemeit is ugyanazzal az elválasztó szöveggel fogja kiírni. 
[ez később módosítva lesz]ó

%----------------------------------------------------------------------------
\subsection{A Refe típus}
%----------------------------------------------------------------------------

A szakdolgozat kiírás egyik legfontosabb pontja az volt, hogy lehessen az IRTG-k bemenetét REGEX kifejezésekkel megadni.
Az volt az elképzelés, hogy ekkor minden arra illeszkedő nem terminális szimbólummal elérhető lesz az átírási szabály.
Ennek a funkcionalitásnak a megvalósítása a Refe.

A Refe érdekessége, hogy félúton van egy Vari és egy Oper között.
Egy Cont változó ként viselkedik, de nem tárolja el az elemeit.
Egy típus(typeRest) megkötésből és egy REGEX(regex) mintából áll.
Deklarációnál is ezt kell megadni vesszővel elválasztva.
Ezek csak az attribútumok közvetlen meghivatozásával elérhetőek.
Amikor az elemeit meghivatkozzuk, akkor kikeresi az adott típusú változókból azokat,
melyek path-ja illeszkedik a REGEX-re.
Ezeket egy listában adja vissza legtöbbször.

Operátor, mivel a változókat mindig újra összegyűjti, és vissza is téríti listában.

Van típus zárójele:

REFE: \{\& Type , t[123] \&\}

A REFE-ben minden whitespace karakter szöktetésre kerül.
A REFE-ben sem lehet egyszerre több műveletet végezni jelenleg, bár ez a későbbiekben változni fog.
A REFE alapjáraton a kikeresett elemeket téríti vissza.
Ha viszont egy Refe típusú Vari-nak adjuk érték ként, akkor az felismeri, hogy referenciáról van szó.

\{= refe1 : Refe := \{\& Spec ,$\land$ spec[123]\$\&\} =\}

Visszatérési értékéből lista is példányosítható:

\{= specL1 : List:Spec := \{\&Spec ,$\land$ spec[123]\$\&\} =\}

és minden, ami listával inicializálható:

\{= temp1 : Temp := \{\&Spec ,$\land$ spec[123]\$\&\} =\}

\{= inst1 : Type1 := \{\&Spec ,$\land$ spec[123]\$\&\} =\}

Mindi abból a fájlból kiindulva fog keresni, ahonnan létrehozták.
Így segítségével lehet halmazokat kezelni.
Ha például irtg szabályokat tárolunk Temp-ekben, amiknek a nevébe kódoljuk a típusukat(NNrule1, NNrule2 ...),
akkor azok egy Refe-vel meghivatkozhatóak:

\{\& Temp: NNrule[0-9]+ \&\}

Ha még csak az NNrule-oknak alapul szolgáló Temp létezik NNruleBase néven, 
és az abba beszúrandó adatok  NNdataBase típusú Inst-ekben (NNdata1, NNdata2 ...),
akkor a Tempek elkészítése és listába mentése is tömören elvégezhető:

\{= NNrules : List:Temp := \{+ NNruleBase +: \{= :Iter:Temp := \{\& NNdataBase: NNdata[0-9]+ \&\} =\} +\} =\}

Segítségével a törlés elvégezhető:

\{x temp1 ; specL1; \{\& NNdataBase: NNdata[0-9]+ \&\} x\}

Ekkor a törlés minden név szerint megtörténik.


%----------------------------------------------------------------------------
\subsection{Haladó Szintaxis}
%----------------------------------------------------------------------------
Persze a zárójelezés jelentős áldozatokat jelent a programozás hatékonyságának terén. 
Nagyon macerás minden műveletnél egy nyitó és egy csukó zárójelet is rakni. 
Éppen ezért két lehetőség is van tömörítésre.

Az első lehetőség az egysoros és kompakt zárójelek használata. 
Az egysoros zárójelek a sor végéig tartanak és a kompakt zárójelek pedig az első whitespace karakterig. 
Így ezeknek végén nem kell csukó zárójelet rakni. 
Az egy soros zárójeleket kapcsos helyett szögletes zárójellel jelöljük, a kompakt zárójeleket pedig kacsacsőr zárójellel. 
Így például a deklaráció \{= … =\} zárójelének az egysoros párja a [= … és a kompakt pedig a <=… zárójelek.

A második megoldás az, hogy egy zárójelben többet is végezhetünk az annak megfelelő műveletből pontosvesszővel elválasztva. 
Ez a jelölés is természetesen a C alapú nyelvekből származik. 
Persze az egysoros műveletek miatt legtöbbször a sorok elejére kerül a pontosvessző. 
Így egyébként elfelejteni is nehezebb és egybevonható a következő sort nyitó zárójellel, ha az azzal kezdődik. 
Sok nyelvben megoldották már a pontosvesszők elhagyását, de több helyen is problémás lett volna.
Például a sablonoknál is problémát jelentett volna, ha több soros szövegeket soronként lehet csak létrehozni. 
(későbbiekben persze egyes műveleteknél erre is sor kerülhet)

A nyelvben létező műveleteket a következőképpen jelöljük:

\begin{center}
  \begin{tabular}{ | l | c | c | l | l | }
    \hline
    művelet		& kódnév 	& blokkos 		& egysoros 	& kompakt	\\ \hline
    komment		& COMM 		& \{\# …\#\} 	& [\# … 	& <\# … 	\\ \hline
    szöveg 		& TEXT 		& \{" …"\} 		& [" … 		& <" … 		\\ \hline
    speciális	& SPEC 		& \{@ …@\} 		& [@ … 		& <@ … 		\\ \hline
    mező 		& SLOT 		& \{\$ …\$\} 	& [\$ … 	& <\$ … 	\\ \hline
    sablon 		& TEMP 		& \{| …|\} 		& [| … 		& <| … 		\\ \hline
    referencia	& REFE 		& \{\& …\&\} 	& [\& … 	& <\& … 	\\ \hline 
    deklaráció 	& DECL 		& \{= …=\} 		& [= … 		& <= … 		\\ \hline
    törlés 		& DELE 		& \{x …x\} 		& [x … 		& <x … 		\\ \hline
    hozzáadás	& PLUS 		& \{+ …+\} 		& [+ … 		& <+ … 		\\ \hline
    kiterjesztés& EXTE 		& \{* …*\} 		& [* … 		& <* … 		\\
    \hline
  \end{tabular}
\end{center}
	 	 	
Érdekesség:
A nyelv neve onnan ered, hogy a műveletek blokkos jelölése a fantasy irodalom slime fajának példányaira emlékeztetnek.
Ekkor az művelet típust jelölő karakterek a lény szemei. 
Az egysoros zárójelekre half slime és a kompaktra pedig slime eye ként is szoktunk hivatkozni szlengesen.

Azt is jó kihasználni, hogy egymásba ágyazott zárójeleknél a beágyazottak nem függenek a befoglaló zárójel típusától. 
Így egy kompakt zárójelbe ágyazott egysoros zárójel továbbra is csak az első sortörés zár, ahogy a blokkosat is csak a csukó zárójel. 
Ez persze az egysoros zárójelbe ágyazott blokkos zárójelre is teljesül. 
Pélául ez egy Temp-et hoz létre három Spec-ből: <|[@ enter; enter; tabulator

A whitespace-k kezelése másban is eltérhetnek zárójel típusonként. 
Például az egysoros és kompakt zárójeleknek legtöbbször nem része az őket záró whitespace. 
Ezért zár több egymásba ágyazott egysor zárójelet is a sort záró sortörés. 
A kompakt Spec és Slot zárójeleknek viszont része az őket záró whitesspace [Ezt még be kell vezetni … ]. 
Általánosságban a zárójelek minden belső whitespace karaktert figyelmen kívül hagynak. 
Az alárendelt nyelvbe ágyazott minden speciális zárójel előtti whitespace is kimarad a kimenetből. 
Text zárójelben minden whitespace megmarad. 
Temp esetében a sor törő, végi és eleji whitespace-k maradnak csak ki. 
Temp-ben ezen kívül nincs minden szöveg Text zárójelben. 
A legtöbb a beágyazott zárójeleken kívül helyezkedik el. 
Éppen ezért van szükség kompakt Slot és Spec esetén, arra hogy a záró whitespace ne a környezet része legyen. 
Különben a kompakt zárójelek nagyon beleolvadnának (Refe : Ezt még be kell vezetni … )


%----------------------------------------------------------------------------
\subsection{Nevek}
%----------------------------------------------------------------------------
A változók nevei a Name nevű változóval manipulálhatóak.
Igaz már korábban is említettem, hogy ez a típus a következő verzióban már nem fog szerepelni.
Lényegében egy Text.
A típus különbség csak a fordítót segíti abban, hogy mikor kívánunk név manipulációt végezni.
Például, ha egy Temp-be egy List:Text-et szúrunk, akkor az alapjáraton a végéhez konkatenálódik.
Onnan tudja a fordító, hogy új neveket akarunk valójában a Temp-hez adni, hogy List:Name típusú, nem List:Text.

Deklarálni ugyanazokon a módokon lehet:

\{= n : Name := \{"Name"\} =\}

vagy

\{= n : Name := Name =\}

Lista viszon készíthető belőle így is:

\{= nList : List:Name := name1, name2, name3 =\}


%----------------------------------------------------------------------------
\section{Implementáció}
%----------------------------------------------------------------------------
A fordító jelenlegi implementációja Kotlinban készült (link … ).

Az implementáció ANTLR-t (link … ) használ a parszoláshoz. 
Az ANTLR a szintaktikai elemzés során feltokenezi a szöveget és szintaktikai fát épít. 
A tokenezéshez szüksége van egy lexer grammar-re (SlimeLexer.g4), és a fa felépítéséhez egy parser grammar-re(SlimeParser.g4). 
Ezek tartalmazzák a nyelv nyelvtanának átírási szabályait, és a tokenezéshez szükséges REGEX szerű, de annál fejlettebb mintákat. 
Az ANTLR ezekből a nyelvtanokból osztályokat generál. 
Sok nyelvben képes erre. 
Ugyanakkor Kotlinban még nem képes, így Java osztályokat generáltatunk vele. 
Ezek az osztályok végzik a tokenezést (SlimeLexer) és a parszolást(SlimeParser). 
Ezen kívül olyan osztályokat is generál, amik alapul szolgálnak a  szemantika megvalósításához. 
Ehhez a fa bejárásának két módja a listeneres(SlimeParserBaseListener) és visitoros(SlimeParserBaseVisitor).
Én a visitoros bejárást választottam.

A lexer nyelvtan fragment-ekből és lexer rule-okból áll. 
A fragmentek önmagukban nem azonosítanak tokent, de részei lehetnek lexer szabályoknak. 
Többek között arra jók, hogy tömörebben írhassunk le hasonló szabályokat, vagy olyan szabályokat, amikben sok az ismétlés. 
Erre ugyanakkor nem mindig képes.

A lexer szabályok azonosítják a tokeneket
A Slime esetén a tokeneket az alárendelt nyelv kód részei, a nyitó és csukó zárójelek, elválasztó karakterek és változó nevek teszik ki.

A lexer képes váltogatni módok között, amikben más lexer szabályok lesznek érvényesek. 
A módokat verem módjára kezeli az ANTLR. 
Megadható, hogy mely tokenek esetén menjen be egy adott módba és az is, hogy annak a módnak mely tokenjei esetén térjen vissza. 
Például ilyen, hogy “{|” esetén belépünk a Temp belsejében érvényes szintaxis lexer módjába és “|}” esetén pedig visszatérünk. 
A parser és lexer nyelvtan össze is vonható, de vegyes nyelvtanban nem lehet a lexernek több módja.
Így a Slime nem lett volna megvalósítható.
Nagy gyengesége a nyelvnek, hogy nem tartozhatnak a szabályok több módhoz is. 
Így a Slot nyitó zárójelét is hét különböző token kezeli attól függően, hogy melyik módból akarjuk elérni. 
Ugyanakkor a fragmentek  minden mode alatt elérhetőek. 
Használjuk is őket, de nem jelent tömörítést, ha a “{|” zárójelet egy minimum két karakteres nevű fragment-be csomagoljuk. 
Minden speciális zárójelnek külön módja van, kivéve a 4 operátor zárójelnek (OPER) és a SLOT-SPEC párosának (SLSP). 
Ezen kívül minden módnak be kellett vezetni egy egysoros és kompakt változatát is, mert másképp nem megoldható a whitespace-k egyedi kezelése.

Erre is jó megoldást nyújt a Slime. 
Van a kódban 27 nem üres sor a nyitó zárójelek kezelésére, ami négyszer is előfordul.
Előfordulásonként a szabályok nevének pár karaktere tér el, és önmagában is sok ismétlést tartalmaz. 
Ennek karbantartása már template-eléssel nem jelentene problémát. 
Sőt template-eléssel a fragmentek is teljes mértékben kiválthatóak.

A parser szabályok már a lexer és más parser szabályokból építkeznek. 
Ezek feladata felismerni az egyes műveleteket és beazonosítani az attribútumokat. 
Az egységesség céljából minden művelet parser szabálya egy head body és tail részből áll.
Ebből a head és a tail csak a nyitó és csukó zárójelek és csukó whitespacek. 
Igaz, még itt is jól látszanak az ANTLR hiányosságai, mivel a head-ek némeike 21 token-ből áll (3 féle nyitó zárójel 7 módban). 
Az összetettebb zárójeleknél, mint Decl, Exte vagy Plus, a body további bodyPart-okra van bontva. 
Az ANTLR minden parser szabályra generál egy leszármazottat a parsz fája csúcsából. 
Ezekre az osztályokra tartalmaz a visitor osztály visit függvényeket. 
A Slime esetében ez a visitor alap a SlimeParserBaseVisitor.
A belőle származtatott osztályom a MySlimeParserVisitor valósítja meg a fordító legfőbb funkcionalitását. 
Minden zárójel parszer szabályának a body-ja állítja elő a valódi kimenetet, amit ő csak továbbít. 
Összetettebb esetekben a body is csak a bodyPart-ok végeredményének az összegzését végzi. 
Ez a kimenet pedig mindig valamilyen a Slime-ban létező típussal rendelkezik.

A Slime típusainak mind létezik a háttérben megfelelő osztály, ami S{$ typeName $} módra van elnevezve. 
Mindegyik az SVari absztrakt ős osztályból származik.
Az SVari tartalmazza a változó neveit és a Slime beli típusának a nevét.
Biztosítja, hogy a változó elérhető legyen a nevein keresztül.
Minden változónak lekérhetőek a nevei(names), önmaga(self), a névtelen másolata(copy) és névvel együttes másolata(copyN).
Tartalmaz alap függvényt a nyelv alap működéseihez.
\begin{itemize}
\item \emph{listPaths:} Kilistázza az adott változóból elérhető összes változó onnan viszonyított útját.
\item \emph{copy:} Lemásolja az adott változót adott néven
\item \emph{extend:}Megvalósítja az EXTE zárójel funkcióját.
\item \emph{plus:}Megvalósítja a PLUS zárójel funkcióját
\item \emph{get:}Lekérdez egy path-on lévő változót
\item \emph{delete:}Töröl egy path-ról egy változót
\item \emph{accept:}Megvalósítja a visitor patternt
\end{itemize}

SName és SText esetén egy String az egyetlen adat, amit lékezelünk. Azt kapja meg a másolat, azt téríti vissza az extend. Hozzáadni csak a változó neveihez lehet. Lekérdezni csak a minden változóból lekérhető négy attribútumot lehet.
Az SSpec egy belső enum osztályt tárol, amiben a kulcsszó-karakter megfeleltetéseket tárolja. Ezen kívül minden példány csak a kulccsal rendelkezik, amin keresztül az értékét lekérheti az enumerációból.
Az SSlot-nak van egy nullable STemp változója. A legtöbb művelete esetén annak továbbítja a hívásokat. cont néven ez a Temp közvetlen a slotból is lekérhető.
Az STemp


agramatikus;6-os a maiból;dávid email;szöveg tisztázása;bevezetők;latexbe;ábrák;Slime;egyszerű kétemeletű példa;10 darabra

bme szabályzat alján két fontos link!
záróvizsga feltétele a végbizonyítvány szerzés.
Annak az igazolása, hogy eleget tettünk a kritériumnak.




%----------------------------------------------------------------------------
\section{A fejlesztés fázisai}
%----------------------------------------------------------------------------
A Slime sok iteráción ment keresztül és mégg sok iteráción is fog végig menni. 
A fázisok sorrendjét is sok szempont befojásolja.

Az első fázis legfőbb célja az alapvető működésnek a megvalósítása volt. 
Csupán a TEXT, SPEC, SLOT, TEMP, DECL, DELE, PLUS és EXTE típusokat tartalmazta.
Típusok közül is csak a négy típus jelölő zárójelhez tartozó tíousokat jelölte.
Nem volt lehetséges sem importálni, se referenciát használni, sem a neveket manipulálni.
Sokkal inkább volt egy prove of concept, mint valós nyelv. 
Sok jelölés eltért a véglegestől

A második fázisban jelentek meg a többi típus és zárójel.
Minden a File, Name és Iter kivételével.
Már ekkor is a nyelvvel hatékony eredményeket lehetett elérni a redundancia csökkentésben.



A harmadik fázisban jelent meg a kommentelés és az egysoros és kompakt zárójelek.


%----------------------------------------------------------------------------
\section{Fejlett megoldásaink}
%----------------------------------------------------------------------------
